# Orval Hooks Generation Analysis

## Can the hooks in `/hooks` be generated by Orval?

**Short Answer:** Partially. Orval generates basic CRUD hooks, but your custom hooks contain sophisticated business logic that cannot be auto-generated.

## What Orval DOES Generate ✅

Orval already generates **basic React Query hooks** for all your API endpoints:

### Query Hooks (GET requests)
```typescript
// Already generated in eventFormsAPI.ts
useGetEventsEventId(eventId)           // Get event by ID
useGetEventsEventIdPersons(eventId)    // Get all persons for event
useGetEventsEventIdVehicles(eventId)   // Get all vehicles for event
useGetEventsEventIdProducts(eventId)   // Get all products for event
```

### Mutation Hooks (POST/PUT/PATCH/DELETE)
```typescript
// Already generated in eventFormsAPI.ts
usePatchEventsEventId()                      // Update event fields
usePostEventsEventIdPersons()                // Create person
usePutEventsEventIdPersonsPersonId()         // Update person
useDeleteEventsEventIdPersonsPersonId()      // Delete person
// Similar hooks for vehicles and products
```

## What Orval CANNOT Generate ❌

Your custom hooks contain **business logic** that orval cannot auto-generate:

### 1. **Atomic Field Updates** (`useAtomicField`)
- ✨ **Debounced saves** (500ms delay)
- ✨ **Optimistic UI updates**
- ✨ **Automatic error handling & rollback**
- ✨ **Nested field path support** (`metadata.title`)
- ✨ **Local state management**

### 2. **Entity-Specific Atomic Updates**
- `useAtomicPersonField` - Person-specific field updates
- `useAtomicVehicleField` - Vehicle-specific field updates  
- `useAtomicProductField` - Product-specific field updates

### 3. **Complex Validation Hooks**
- `useEventValidation` - Multi-level validation with memoization
- `useFieldValidation` - Real-time field validation
- `useSectionValidation` - Section-specific validation logic

## Hybrid Approach: Best of Both Worlds 🔄

### Strategy: Build Custom Logic on Orval Foundation

Instead of replacing your custom hooks, **enhance them** to use orval-generated base hooks:

```typescript
// Before: Manual API calls
const updateField = async (value) => {
  const response = await fetch(`/api/events/${eventId}`, {
    method: 'PATCH',
    body: JSON.stringify({ [fieldPath]: value })
  });
  // Manual error handling, cache updates, etc.
};

// After: Using orval-generated hook as foundation
const patchEventMutation = usePatchEventsEventId({
  mutation: {
    onSuccess: (data) => {
      // Your custom success logic
    },
    onError: (error) => {
      // Your custom error handling
    }
  }
});
```

## Enhanced Hook Examples

I've created enhanced versions that demonstrate this approach:

### 1. **Enhanced Atomic Field Hook**
```typescript
// useAtomicField-enhanced.ts
export function useAtomicFieldEnhanced({
  eventId,
  fieldPath,
  initialValue,
  debounceMs = 500,
}) {
  // Uses orval-generated usePatchEventsEventId as foundation
  const patchEventMutation = usePatchEventsEventId({
    mutation: {
      // Your custom optimistic updates
      // Your custom error handling
      // Your custom success callbacks
    }
  });
  
  // Your custom debouncing logic
  // Your custom local state management
  // Your custom nested field path handling
}
```

### 2. **Enhanced Validation Hook**
```typescript
// useEventValidation-enhanced.ts
export function useEventValidationEnhanced({ eventId }) {
  // Uses orval-generated useGetEventsEventId as foundation
  const { data: event } = useGetEventsEventId(eventId);
  
  // Uses orval-generated Zod schemas for validation
  const validationResult = validateEventWithOrval(event);
  
  // Your custom validation summary logic
  // Your custom memoization
  // Your custom error aggregation
}
```

## Benefits of the Hybrid Approach

### ✅ **Reduced Boilerplate**
- Orval handles API calls, TypeScript types, and basic React Query setup
- You focus on business logic and UX enhancements

### ✅ **Automatic API Sync**
- API changes automatically update the base hooks
- Your custom logic remains intact

### ✅ **Type Safety**
- Orval-generated hooks are fully typed
- Your enhancements inherit the type safety

### ✅ **Best Practices**
- Orval follows React Query best practices
- Your custom logic adds domain-specific optimizations

## Migration Strategy

### Phase 1: Parallel Implementation
```
src/hooks/
├── useAtomicField.ts              # Original (keep)
├── useAtomicField-enhanced.ts     # New hybrid version
├── useEventValidation.ts          # Original (keep)
└── useEventValidation-enhanced.ts # New hybrid version
```

### Phase 2: Gradual Migration
- Test enhanced hooks in new components
- Compare behavior with original hooks
- Migrate existing components one by one

### Phase 3: Full Migration
- Replace original hooks with enhanced versions
- Remove duplicate code
- Rely on orval for API layer

## Factory Pattern for Repetitive Hooks

For the repetitive entity-specific hooks, you can use a factory pattern:

```typescript
// Create entity-specific hooks programmatically
export const useAtomicPersonField = createEntityAtomicFieldHook(
  usePutEventsEventIdPersonsPersonId,
  'person'
);

export const useAtomicVehicleField = createEntityAtomicFieldHook(
  usePutEventsEventIdVehiclesVehicleId,
  'vehicle'
);

export const useAtomicProductField = createEntityAtomicFieldHook(
  usePutEventsEventIdProductsProductId,
  'product'
);
```

## Conclusion

**Orval generates the foundation, you add the sophistication.**

- ✅ **Basic CRUD hooks**: Auto-generated by orval
- ✅ **Type safety**: Auto-generated by orval  
- ✅ **API sync**: Auto-maintained by orval
- 🎨 **Business logic**: Custom hooks built on orval foundation
- 🎨 **UX enhancements**: Debouncing, optimistic updates, validation
- 🎨 **Domain logic**: Event-specific validation, atomic updates

This hybrid approach gives you the best of both worlds: automated API layer generation with custom business logic on top.
